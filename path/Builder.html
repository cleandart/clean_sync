        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Builder class / path Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="path" data-type="Builder">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../path.html">path</a> &rsaquo; <a href="../path/Builder.html">Builder</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Builder</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An instantiable class for manipulating paths. Unlike the top-level
functions, this lets you explicitly select what platform the paths will use.</p>
<pre class="source">
class Builder {
 /// Creates a new path builder for the given style and root directory.
 ///
 /// If [style] is omitted, it uses the host operating system's path style. If
 /// only [root] is omitted, it defaults ".". If *both* [style] and [root] are
 /// omitted, [root] defaults to the current working directory.
 ///
 /// On the browser, the path style is [Style.url]. In Dartium, [root] defaults
 /// to the current URL. When using dart2js, it currently defaults to `.` due
 /// to technical constraints.
 factory Builder({Style style, String root}) {
   if (root == null) {
     if (style == null) {
       root = current;
     } else {
       root = ".";
     }
   }

   if (style == null) style = Style.platform;

   return new Builder._(style, root);
 }

 Builder._(this.style, this.root);

 /// The style of path that this builder works with.
 final Style style;

 /// The root directory that relative paths will be relative to.
 final String root;

 /// Gets the path separator for the builder's [style]. On Mac and Linux,
 /// this is `/`. On Windows, it's `\`.
 String get separator =&gt; style.separator;

 /// Gets the part of [path] after the last separator on the builder's
 /// platform.
 ///
 ///     builder.basename('path/to/foo.dart'); // -&gt; 'foo.dart'
 ///     builder.basename('path/to');          // -&gt; 'to'
 ///
 /// Trailing separators are ignored.
 ///
 ///     builder.basename('path/to/'); // -&gt; 'to'
 String basename(String path) =&gt; _parse(path).basename;

 /// Gets the part of [path] after the last separator on the builder's
 /// platform, and without any trailing file extension.
 ///
 ///     builder.basenameWithoutExtension('path/to/foo.dart'); // -&gt; 'foo'
 ///
 /// Trailing separators are ignored.
 ///
 ///     builder.basenameWithoutExtension('path/to/foo.dart/'); // -&gt; 'foo'
 String basenameWithoutExtension(String path) =&gt;
   _parse(path).basenameWithoutExtension;

 /// Gets the part of [path] before the last separator.
 ///
 ///     builder.dirname('path/to/foo.dart'); // -&gt; 'path/to'
 ///     builder.dirname('path/to');          // -&gt; 'path'
 ///
 /// Trailing separators are ignored.
 ///
 ///     builder.dirname('path/to/'); // -&gt; 'path'
 String dirname(String path) {
   var parsed = _parse(path);
   parsed.removeTrailingSeparators();
   if (parsed.parts.isEmpty) return parsed.root == null ? '.' : parsed.root;
   if (parsed.parts.length == 1) {
     return parsed.root == null ? '.' : parsed.root;
   }
   parsed.parts.removeLast();
   parsed.separators.removeLast();
   parsed.removeTrailingSeparators();
   return parsed.toString();
 }

 /// Gets the file extension of [path]: the portion of [basename] from the last
 /// `.` to the end (including the `.` itself).
 ///
 ///     builder.extension('path/to/foo.dart'); // -&gt; '.dart'
 ///     builder.extension('path/to/foo'); // -&gt; ''
 ///     builder.extension('path.to/foo'); // -&gt; ''
 ///     builder.extension('path/to/foo.dart.js'); // -&gt; '.js'
 ///
 /// If the file name starts with a `.`, then it is not considered an
 /// extension:
 ///
 ///     builder.extension('~/.bashrc');    // -&gt; ''
 ///     builder.extension('~/.notes.txt'); // -&gt; '.txt'
 String extension(String path) =&gt; _parse(path).extension;

 // TODO(nweiz): add a UNC example for Windows once issue 7323 is fixed.
 /// Returns the root of [path], if it's absolute, or an empty string if it's
 /// relative.
 ///
 ///     // Unix
 ///     builder.rootPrefix('path/to/foo'); // -&gt; ''
 ///     builder.rootPrefix('/path/to/foo'); // -&gt; '/'
 ///
 ///     // Windows
 ///     builder.rootPrefix(r'path\to\foo'); // -&gt; ''
 ///     builder.rootPrefix(r'C:\path\to\foo'); // -&gt; r'C:\'
 ///
 ///     // URL
 ///     builder.rootPrefix('path/to/foo'); // -&gt; ''
 ///     builder.rootPrefix('http://dartlang.org/path/to/foo');
 ///       // -&gt; 'http://dartlang.org'
 String rootPrefix(String path) {
   var root = _parse(path).root;
   return root == null ? '' : root;
 }

 /// Returns `true` if [path] is an absolute path and `false` if it is a
 /// relative path.
 ///
 /// On POSIX systems, absolute paths start with a `/` (forward slash). On
 /// Windows, an absolute path starts with `\\`, or a drive letter followed by
 /// `:/` or `:\`. For URLs, absolute paths either start with a protocol and
 /// optional hostname (e.g. `http://dartlang.org`, `file://`) or with a `/`.
 ///
 /// URLs that start with `/` are known as "root-relative", since they're
 /// relative to the root of the current URL. Since root-relative paths are
 /// still absolute in every other sense, [isAbsolute] will return true for
 /// them. They can be detected using [isRootRelative].
 bool isAbsolute(String path) =&gt; _parse(path).isAbsolute;

 /// Returns `true` if [path] is a relative path and `false` if it is absolute.
 /// On POSIX systems, absolute paths start with a `/` (forward slash). On
 /// Windows, an absolute path starts with `\\`, or a drive letter followed by
 /// `:/` or `:\`.
 bool isRelative(String path) =&gt; !this.isAbsolute(path);

 /// Returns `true` if [path] is a root-relative path and `false` if it's not.
 ///
 /// URLs that start with `/` are known as "root-relative", since they're
 /// relative to the root of the current URL. Since root-relative paths are
 /// still absolute in every other sense, [isAbsolute] will return true for
 /// them. They can be detected using [isRootRelative].
 ///
 /// No POSIX and Windows paths are root-relative.
 bool isRootRelative(String path) =&gt; _parse(path).isRootRelative;

 /// Joins the given path parts into a single path. Example:
 ///
 ///     builder.join('path', 'to', 'foo'); // -&gt; 'path/to/foo'
 ///
 /// If any part ends in a path separator, then a redundant separator will not
 /// be added:
 ///
 ///     builder.join('path/', 'to', 'foo'); // -&gt; 'path/to/foo
 ///
 /// If a part is an absolute path, then anything before that will be ignored:
 ///
 ///     builder.join('path', '/to', 'foo'); // -&gt; '/to/foo'
 ///
 String join(String part1, [String part2, String part3, String part4,
             String part5, String part6, String part7, String part8]) {
   var parts = [part1, part2, part3, part4, part5, part6, part7, part8];
   _validateArgList("join", parts);
   return joinAll(parts.where((part) =&gt; part != null));
 }

 /// Joins the given path parts into a single path. Example:
 ///
 ///     builder.joinAll(['path', 'to', 'foo']); // -&gt; 'path/to/foo'
 ///
 /// If any part ends in a path separator, then a redundant separator will not
 /// be added:
 ///
 ///     builder.joinAll(['path/', 'to', 'foo']); // -&gt; 'path/to/foo
 ///
 /// If a part is an absolute path, then anything before that will be ignored:
 ///
 ///     builder.joinAll(['path', '/to', 'foo']); // -&gt; '/to/foo'
 ///
 /// For a fixed number of parts, [join] is usually terser.
 String joinAll(Iterable&lt;String&gt; parts) {
   var buffer = new StringBuffer();
   var needsSeparator = false;
   var isAbsoluteAndNotRootRelative = false;

   for (var part in parts.where((part) =&gt; part != '')) {
     if (this.isRootRelative(part) &amp;&amp; isAbsoluteAndNotRootRelative) {
       // If the new part is root-relative, it preserves the previous root but
       // replaces the path after it.
       var oldRoot = this.rootPrefix(buffer.toString());
       buffer.clear();
       buffer.write(oldRoot);
       buffer.write(part);
     } else if (this.isAbsolute(part)) {
       isAbsoluteAndNotRootRelative = !this.isRootRelative(part);
       // An absolute path discards everything before it.
       buffer.clear();
       buffer.write(part);
     } else {
       if (part.length &gt; 0 &amp;&amp; part[0].contains(style.separatorPattern)) {
         // The part starts with a separator, so we don't need to add one.
       } else if (needsSeparator) {
         buffer.write(separator);
       }

       buffer.write(part);
     }

     // Unless this part ends with a separator, we'll need to add one before
     // the next part.
     needsSeparator = part.contains(style.needsSeparatorPattern);
   }

   return buffer.toString();
 }

 // TODO(nweiz): add a UNC example for Windows once issue 7323 is fixed.
 /// Splits [path] into its components using the current platform's
 /// [separator]. Example:
 ///
 ///     builder.split('path/to/foo'); // -&gt; ['path', 'to', 'foo']
 ///
 /// The path will *not* be normalized before splitting.
 ///
 ///     builder.split('path/../foo'); // -&gt; ['path', '..', 'foo']
 ///
 /// If [path] is absolute, the root directory will be the first element in the
 /// array. Example:
 ///
 ///     // Unix
 ///     builder.split('/path/to/foo'); // -&gt; ['/', 'path', 'to', 'foo']
 ///
 ///     // Windows
 ///     builder.split(r'C:\path\to\foo'); // -&gt; [r'C:\', 'path', 'to', 'foo']
 List&lt;String&gt; split(String path) {
   var parsed = _parse(path);
   // Filter out empty parts that exist due to multiple separators in a row.
   parsed.parts = parsed.parts.where((part) =&gt; !part.isEmpty)
                              .toList();
   if (parsed.root != null) parsed.parts.insert(0, parsed.root);
   return parsed.parts;
 }

 /// Normalizes [path], simplifying it by handling `..`, and `.`, and
 /// removing redundant path separators whenever possible.
 ///
 ///     builder.normalize('path/./to/..//file.text'); // -&gt; 'path/file.txt'
 String normalize(String path) {
   var parsed = _parse(path);
   parsed.normalize();
   return parsed.toString();
 }

 /// Creates a new path by appending the given path parts to the [root].
 /// Equivalent to [join()] with [root] as the first argument. Example:
 ///
 ///     var builder = new Builder(root: 'root');
 ///     builder.resolve('path', 'to', 'foo'); // -&gt; 'root/path/to/foo'
 String resolve(String part1, [String part2, String part3, String part4,
             String part5, String part6, String part7]) {
   return join(root, part1, part2, part3, part4, part5, part6, part7);
 }

 /// Attempts to convert [path] to an equivalent relative path relative to
 /// [root].
 ///
 ///     var builder = new Builder(root: '/root/path');
 ///     builder.relative('/root/path/a/b.dart'); // -&gt; 'a/b.dart'
 ///     builder.relative('/root/other.dart'); // -&gt; '../other.dart'
 ///
 /// If the [from] argument is passed, [path] is made relative to that instead.
 ///
 ///     builder.relative('/root/path/a/b.dart',
 ///         from: '/root/path'); // -&gt; 'a/b.dart'
 ///     builder.relative('/root/other.dart',
 ///         from: '/root/path'); // -&gt; '../other.dart'
 ///
 /// If [path] and/or [from] are relative paths, they are assumed to be
 /// relative to [root].
 ///
 /// Since there is no relative path from one drive letter to another on
 /// Windows, this will return an absolute path in that case.
 ///
 ///     builder.relative(r'D:\other', from: r'C:\other'); // -&gt; 'D:\other'
 ///
 /// This will also return an absolute path if an absolute [path] is passed to
 /// a builder with a relative [root].
 ///
 ///     var builder = new Builder(r'some/relative/path');
 ///     builder.relative(r'/absolute/path'); // -&gt; '/absolute/path'
 String relative(String path, {String from}) {
   from = from == null ? root : this.join(root, from);

   // We can't determine the path from a relative path to an absolute path.
   if (this.isRelative(from) &amp;&amp; this.isAbsolute(path)) {
     return this.normalize(path);
   }

   // If the given path is relative, resolve it relative to the root of the
   // builder.
   if (this.isRelative(path) || this.isRootRelative(path)) {
     path = this.resolve(path);
   }

   // If the path is still relative and `from` is absolute, we're unable to
   // find a path from `from` to `path`.
   if (this.isRelative(path) &amp;&amp; this.isAbsolute(from)) {
     throw new ArgumentError('Unable to find a path to "$path" from "$from".');
   }

   var fromParsed = _parse(from)..normalize();
   var pathParsed = _parse(path)..normalize();

   if (fromParsed.parts.length &gt; 0 &amp;&amp; fromParsed.parts[0] == '.') {
     return pathParsed.toString();
   }

   // If the root prefixes don't match (for example, different drive letters
   // on Windows), then there is no relative path, so just return the absolute
   // one. In Windows, drive letters are case-insenstive and we allow
   // calculation of relative paths, even if a path has not been normalized.
   if (fromParsed.root != pathParsed.root &amp;&amp;
       ((fromParsed.root ==  null || pathParsed.root == null) ||
         fromParsed.root.toLowerCase().replaceAll('/', '\\') !=
         pathParsed.root.toLowerCase().replaceAll('/', '\\'))) {
     return pathParsed.toString();
   }

   // Strip off their common prefix.
   while (fromParsed.parts.length &gt; 0 &amp;&amp; pathParsed.parts.length &gt; 0 &amp;&amp;
          fromParsed.parts[0] == pathParsed.parts[0]) {
     fromParsed.parts.removeAt(0);
     fromParsed.separators.removeAt(1);
     pathParsed.parts.removeAt(0);
     pathParsed.separators.removeAt(1);
   }

   // If there are any directories left in the from path, we need to walk up
   // out of them. If a directory left in the from path is '..', it cannot
   // be cancelled by adding a '..'.
   if (fromParsed.parts.length &gt; 0 &amp;&amp; fromParsed.parts[0] == '..') {
     throw new ArgumentError('Unable to find a path to "$path" from "$from".');
   }
   _growListFront(pathParsed.parts, fromParsed.parts.length, '..');
   pathParsed.separators[0] = '';
   pathParsed.separators.insertAll(1,
       new List.filled(fromParsed.parts.length, style.separator));

   // Corner case: the paths completely collapsed.
   if (pathParsed.parts.length == 0) return '.';

   // Corner case: path was '.' and some '..' directories were added in front.
   // Don't add a final '/.' in that case.
   if (pathParsed.parts.length &gt; 1 &amp;&amp; pathParsed.parts.last == '.') {
     pathParsed.parts.removeLast();
     pathParsed.separators..removeLast()..removeLast()..add('');
   }

   // Make it relative.
   pathParsed.root = '';
   pathParsed.removeTrailingSeparators();

   return pathParsed.toString();
 }

 /// Removes a trailing extension from the last part of [path].
 ///
 ///     builder.withoutExtension('path/to/foo.dart'); // -&gt; 'path/to/foo'
 String withoutExtension(String path) {
   var parsed = _parse(path);

   for (var i = parsed.parts.length - 1; i &gt;= 0; i--) {
     if (!parsed.parts[i].isEmpty) {
       parsed.parts[i] = parsed.basenameWithoutExtension;
       break;
     }
   }

   return parsed.toString();
 }

 /// Returns the path represented by [uri].
 ///
 /// For POSIX and Windows styles, [uri] must be a `file:` URI. For the URL
 /// style, this will just convert [uri] to a string.
 ///
 ///     // POSIX
 ///     builder.fromUri(Uri.parse('file:///path/to/foo'))
 ///       // -&gt; '/path/to/foo'
 ///
 ///     // Windows
 ///     builder.fromUri(Uri.parse('file:///C:/path/to/foo'))
 ///       // -&gt; r'C:\path\to\foo'
 ///
 ///     // URL
 ///     builder.fromUri(Uri.parse('http://dartlang.org/path/to/foo'))
 ///       // -&gt; 'http://dartlang.org/path/to/foo'
 String fromUri(Uri uri) =&gt; style.pathFromUri(uri);

 /// Returns the URI that represents [path].
 ///
 /// For POSIX and Windows styles, this will return a `file:` URI. For the URL
 /// style, this will just convert [path] to a [Uri].
 ///
 ///     // POSIX
 ///     builder.toUri('/path/to/foo')
 ///       // -&gt; Uri.parse('file:///path/to/foo')
 ///
 ///     // Windows
 ///     builder.toUri(r'C:\path\to\foo')
 ///       // -&gt; Uri.parse('file:///C:/path/to/foo')
 ///
 ///     // URL
 ///     builder.toUri('http://dartlang.org/path/to/foo')
 ///       // -&gt; Uri.parse('http://dartlang.org/path/to/foo')
 Uri toUri(String path) {
   if (isRelative(path)) {
     return style.relativePathToUri(path);
   } else {
     return style.absolutePathToUri(join(root, path));
   }
 }

 _ParsedPath _parse(String path) {
   var before = path;

   // Remove the root prefix, if any.
   var root = style.getRoot(path);
   var isRootRelative = style.getRelativeRoot(path) != null;
   if (root != null) path = path.substring(root.length);

   // Split the parts on path separators.
   var parts = [];
   var separators = [];

   var firstSeparator = style.separatorPattern.matchAsPrefix(path);
   if (firstSeparator != null) {
     separators.add(firstSeparator[0]);
     path = path.substring(firstSeparator[0].length);
   } else {
     separators.add('');
   }

   var start = 0;
   for (var match in style.separatorPattern.allMatches(path)) {
     parts.add(path.substring(start, match.start));
     separators.add(match[0]);
     start = match.end;
   }

   // Add the final part, if any.
   if (start &lt; path.length) {
     parts.add(path.substring(start));
     separators.add('');
   }

   return new _ParsedPath(style, root, isRootRelative, parts, separators);
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
factory <strong>Builder</strong>({<a href="../path/Style.html">Style</a> style, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> root}) <a class="anchor-link" href="#"
              title="Permalink to Builder.Builder">#</a></h4>
<div class="doc">
<p>Creates a new path builder for the given style and root directory.</p>
<p>If 
<span class="param">style</span> is omitted, it uses the host operating system's path style. If
only 
<span class="param">root</span> is omitted, it defaults ".". If <em>both</em> 
<span class="param">style</span> and 
<span class="param">root</span> are
omitted, 
<span class="param">root</span> defaults to the current working directory.</p>
<p>On the browser, the path style is <a class="crossref" href="../path/Style.html#url">Style.url</a>. In Dartium, 
<span class="param">root</span> defaults
to the current URL. When using dart2js, it currently defaults to <code>.</code> due
to technical constraints.</p>
<pre class="source">
factory Builder({Style style, String root}) {
 if (root == null) {
   if (style == null) {
     root = current;
   } else {
     root = ".";
   }
 }

 if (style == null) style = Style.platform;

 return new Builder._(style, root);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="root">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>root</strong> <a class="anchor-link"
            href="#root"
            title="Permalink to Builder.root">#</a>
        </h4>
        <div class="doc">
<p>The root directory that relative paths will be relative to.</p>
<pre class="source">
final String root
</pre>
</div>
</div>
<div class="field"><h4 id="separator">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>separator</strong> <a class="anchor-link"
            href="#separator"
            title="Permalink to Builder.separator">#</a>
        </h4>
        <div class="doc">
<p>Gets the path separator for the builder's <a class="crossref" href="../path/Builder.html#style">style</a>. On Mac and Linux,
this is <code>/</code>. On Windows, it's <code>\</code>.</p>
<pre class="source">
String get separator =&gt; style.separator;
</pre>
</div>
</div>
<div class="field"><h4 id="style">
<button class="show-code">Code</button>
final <a href="../path/Style.html">Style</a>         <strong>style</strong> <a class="anchor-link"
            href="#style"
            title="Permalink to Builder.style">#</a>
        </h4>
        <div class="doc">
<p>The style of path that this builder works with.</p>
<pre class="source">
final Style style
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="basename">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>basename</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#basename"
              title="Permalink to Builder.basename">#</a></h4>
<div class="doc">
<p>Gets the part of 
<span class="param">path</span> after the last separator on the builder's
platform.</p>
<pre><code>builder.basename('path/to/foo.dart'); // -&gt; 'foo.dart'
builder.basename('path/to');          // -&gt; 'to'
</code></pre>
<p>Trailing separators are ignored.</p>
<pre><code>builder.basename('path/to/'); // -&gt; 'to'
</code></pre>
<pre class="source">
String basename(String path) =&gt; _parse(path).basename;
</pre>
</div>
</div>
<div class="method"><h4 id="basenameWithoutExtension">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>basenameWithoutExtension</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#basenameWithoutExtension"
              title="Permalink to Builder.basenameWithoutExtension">#</a></h4>
<div class="doc">
<p>Gets the part of 
<span class="param">path</span> after the last separator on the builder's
platform, and without any trailing file extension.</p>
<pre><code>builder.basenameWithoutExtension('path/to/foo.dart'); // -&gt; 'foo'
</code></pre>
<p>Trailing separators are ignored.</p>
<pre><code>builder.basenameWithoutExtension('path/to/foo.dart/'); // -&gt; 'foo'
</code></pre>
<pre class="source">
String basenameWithoutExtension(String path) =&gt;
 _parse(path).basenameWithoutExtension;
</pre>
</div>
</div>
<div class="method"><h4 id="dirname">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>dirname</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#dirname"
              title="Permalink to Builder.dirname">#</a></h4>
<div class="doc">
<p>Gets the part of 
<span class="param">path</span> before the last separator.</p>
<pre><code>builder.dirname('path/to/foo.dart'); // -&gt; 'path/to'
builder.dirname('path/to');          // -&gt; 'path'
</code></pre>
<p>Trailing separators are ignored.</p>
<pre><code>builder.dirname('path/to/'); // -&gt; 'path'
</code></pre>
<pre class="source">
String dirname(String path) {
 var parsed = _parse(path);
 parsed.removeTrailingSeparators();
 if (parsed.parts.isEmpty) return parsed.root == null ? '.' : parsed.root;
 if (parsed.parts.length == 1) {
   return parsed.root == null ? '.' : parsed.root;
 }
 parsed.parts.removeLast();
 parsed.separators.removeLast();
 parsed.removeTrailingSeparators();
 return parsed.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="extension">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>extension</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#extension"
              title="Permalink to Builder.extension">#</a></h4>
<div class="doc">
<p>Gets the file extension of 
<span class="param">path</span>: the portion of <a class="crossref" href="../path/Builder.html#basename">basename</a> from the last
<code>.</code> to the end (including the <code>.</code> itself).</p>
<pre><code>builder.extension('path/to/foo.dart'); // -&gt; '.dart'
builder.extension('path/to/foo'); // -&gt; ''
builder.extension('path.to/foo'); // -&gt; ''
builder.extension('path/to/foo.dart.js'); // -&gt; '.js'
</code></pre>
<p>If the file name starts with a <code>.</code>, then it is not considered an
extension:</p>
<pre><code>builder.extension('~/.bashrc');    // -&gt; ''
builder.extension('~/.notes.txt'); // -&gt; '.txt'
</code></pre>
<pre class="source">
String extension(String path) =&gt; _parse(path).extension;
</pre>
</div>
</div>
<div class="method"><h4 id="fromUri">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>fromUri</strong>(<a href="http://api.dartlang.org/dart_core/Uri.html" ref="external">Uri</a> uri) <a class="anchor-link" href="#fromUri"
              title="Permalink to Builder.fromUri">#</a></h4>
<div class="doc">
<p>Returns the path represented by 
<span class="param">uri</span>.</p>
<p>For POSIX and Windows styles, 
<span class="param">uri</span> must be a <code>file:</code> URI. For the URL
style, this will just convert 
<span class="param">uri</span> to a string.</p>
<pre><code>// POSIX
builder.fromUri(Uri.parse('file:///path/to/foo'))
  // -&gt; '/path/to/foo'

// Windows
builder.fromUri(Uri.parse('file:///C:/path/to/foo'))
  // -&gt; r'C:\path\to\foo'

// URL
builder.fromUri(Uri.parse('http://dartlang.org/path/to/foo'))
  // -&gt; 'http://dartlang.org/path/to/foo'
</code></pre>
<pre class="source">
String fromUri(Uri uri) =&gt; style.pathFromUri(uri);
</pre>
</div>
</div>
<div class="method"><h4 id="isAbsolute">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>isAbsolute</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#isAbsolute"
              title="Permalink to Builder.isAbsolute">#</a></h4>
<div class="doc">
<p>Returns <code>true</code> if 
<span class="param">path</span> is an absolute path and <code>false</code> if it is a
relative path.</p>
<p>On POSIX systems, absolute paths start with a <code>/</code> (forward slash). On
Windows, an absolute path starts with <code>\\</code>, or a drive letter followed by
<code>:/</code> or <code>:\</code>. For URLs, absolute paths either start with a protocol and
optional hostname (e.g. <code>http://dartlang.org</code>, <code>file://</code>) or with a <code>/</code>.</p>
<p>URLs that start with <code>/</code> are known as "root-relative", since they're
relative to the root of the current URL. Since root-relative paths are
still absolute in every other sense, <a class="crossref" href="../path/Builder.html#isAbsolute">isAbsolute</a> will return true for
them. They can be detected using <a class="crossref" href="../path/Builder.html#isRootRelative">isRootRelative</a>.</p>
<pre class="source">
bool isAbsolute(String path) =&gt; _parse(path).isAbsolute;
</pre>
</div>
</div>
<div class="method"><h4 id="isRelative">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>isRelative</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#isRelative"
              title="Permalink to Builder.isRelative">#</a></h4>
<div class="doc">
<p>Returns <code>true</code> if 
<span class="param">path</span> is a relative path and <code>false</code> if it is absolute.
On POSIX systems, absolute paths start with a <code>/</code> (forward slash). On
Windows, an absolute path starts with <code>\\</code>, or a drive letter followed by
<code>:/</code> or <code>:\</code>.</p>
<pre class="source">
bool isRelative(String path) =&gt; !this.isAbsolute(path);
</pre>
</div>
</div>
<div class="method"><h4 id="isRootRelative">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>isRootRelative</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#isRootRelative"
              title="Permalink to Builder.isRootRelative">#</a></h4>
<div class="doc">
<p>Returns <code>true</code> if 
<span class="param">path</span> is a root-relative path and <code>false</code> if it's not.</p>
<p>URLs that start with <code>/</code> are known as "root-relative", since they're
relative to the root of the current URL. Since root-relative paths are
still absolute in every other sense, <a class="crossref" href="../path/Builder.html#isAbsolute">isAbsolute</a> will return true for
them. They can be detected using <a class="crossref" href="../path/Builder.html#isRootRelative">isRootRelative</a>.</p>
<p>No POSIX and Windows paths are root-relative.</p>
<pre class="source">
bool isRootRelative(String path) =&gt; _parse(path).isRootRelative;
</pre>
</div>
</div>
<div class="method"><h4 id="join">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>join</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part1, [<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part2, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part3, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part4, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part5, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part6, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part7, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part8]) <a class="anchor-link" href="#join"
              title="Permalink to Builder.join">#</a></h4>
<div class="doc">
<p>Joins the given path parts into a single path. Example:</p>
<pre><code>builder.join('path', 'to', 'foo'); // -&gt; 'path/to/foo'
</code></pre>
<p>If any part ends in a path separator, then a redundant separator will not
be added:</p>
<pre><code>builder.join('path/', 'to', 'foo'); // -&gt; 'path/to/foo
</code></pre>
<p>If a part is an absolute path, then anything before that will be ignored:</p>
<pre><code>builder.join('path', '/to', 'foo'); // -&gt; '/to/foo'
</code></pre>
<pre class="source">
String join(String part1, [String part2, String part3, String part4,
           String part5, String part6, String part7, String part8]) {
 var parts = [part1, part2, part3, part4, part5, part6, part7, part8];
 _validateArgList("join", parts);
 return joinAll(parts.where((part) =&gt; part != null));
}
</pre>
</div>
</div>
<div class="method"><h4 id="joinAll">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>joinAll</strong>(<a href="http://api.dartlang.org/dart_core/Iterable.html" ref="external">Iterable</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>&gt; parts) <a class="anchor-link" href="#joinAll"
              title="Permalink to Builder.joinAll">#</a></h4>
<div class="doc">
<p>Joins the given path parts into a single path. Example:</p>
<pre><code>builder.joinAll(['path', 'to', 'foo']); // -&gt; 'path/to/foo'
</code></pre>
<p>If any part ends in a path separator, then a redundant separator will not
be added:</p>
<pre><code>builder.joinAll(['path/', 'to', 'foo']); // -&gt; 'path/to/foo
</code></pre>
<p>If a part is an absolute path, then anything before that will be ignored:</p>
<pre><code>builder.joinAll(['path', '/to', 'foo']); // -&gt; '/to/foo'
</code></pre>
<p>For a fixed number of parts, <a class="crossref" href="../path/Builder.html#join">join</a> is usually terser.</p>
<pre class="source">
String joinAll(Iterable&lt;String&gt; parts) {
 var buffer = new StringBuffer();
 var needsSeparator = false;
 var isAbsoluteAndNotRootRelative = false;

 for (var part in parts.where((part) =&gt; part != '')) {
   if (this.isRootRelative(part) &amp;&amp; isAbsoluteAndNotRootRelative) {
     // If the new part is root-relative, it preserves the previous root but
     // replaces the path after it.
     var oldRoot = this.rootPrefix(buffer.toString());
     buffer.clear();
     buffer.write(oldRoot);
     buffer.write(part);
   } else if (this.isAbsolute(part)) {
     isAbsoluteAndNotRootRelative = !this.isRootRelative(part);
     // An absolute path discards everything before it.
     buffer.clear();
     buffer.write(part);
   } else {
     if (part.length &gt; 0 &amp;&amp; part[0].contains(style.separatorPattern)) {
       // The part starts with a separator, so we don't need to add one.
     } else if (needsSeparator) {
       buffer.write(separator);
     }

     buffer.write(part);
   }

   // Unless this part ends with a separator, we'll need to add one before
   // the next part.
   needsSeparator = part.contains(style.needsSeparatorPattern);
 }

 return buffer.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="normalize">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>normalize</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#normalize"
              title="Permalink to Builder.normalize">#</a></h4>
<div class="doc">
<p>Normalizes 
<span class="param">path</span>, simplifying it by handling <code>..</code>, and <code>.</code>, and
removing redundant path separators whenever possible.</p>
<pre><code>builder.normalize('path/./to/..//file.text'); // -&gt; 'path/file.txt'
</code></pre>
<pre class="source">
String normalize(String path) {
 var parsed = _parse(path);
 parsed.normalize();
 return parsed.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="relative">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>relative</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path, {<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> from}) <a class="anchor-link" href="#relative"
              title="Permalink to Builder.relative">#</a></h4>
<div class="doc">
<p>Attempts to convert 
<span class="param">path</span> to an equivalent relative path relative to
<a class="crossref" href="../path/Builder.html#root">root</a>.</p>
<pre><code>var builder = new Builder(root: '/root/path');
builder.relative('/root/path/a/b.dart'); // -&gt; 'a/b.dart'
builder.relative('/root/other.dart'); // -&gt; '../other.dart'
</code></pre>
<p>If the 
<span class="param">from</span> argument is passed, 
<span class="param">path</span> is made relative to that instead.</p>
<pre><code>builder.relative('/root/path/a/b.dart',
    from: '/root/path'); // -&gt; 'a/b.dart'
builder.relative('/root/other.dart',
    from: '/root/path'); // -&gt; '../other.dart'
</code></pre>
<p>If 
<span class="param">path</span> and/or 
<span class="param">from</span> are relative paths, they are assumed to be
relative to <a class="crossref" href="../path/Builder.html#root">root</a>.</p>
<p>Since there is no relative path from one drive letter to another on
Windows, this will return an absolute path in that case.</p>
<pre><code>builder.relative(r'D:\other', from: r'C:\other'); // -&gt; 'D:\other'
</code></pre>
<p>This will also return an absolute path if an absolute 
<span class="param">path</span> is passed to
a builder with a relative <a class="crossref" href="../path/Builder.html#root">root</a>.</p>
<pre><code>var builder = new Builder(r'some/relative/path');
builder.relative(r'/absolute/path'); // -&gt; '/absolute/path'
</code></pre>
<pre class="source">
String relative(String path, {String from}) {
 from = from == null ? root : this.join(root, from);

 // We can't determine the path from a relative path to an absolute path.
 if (this.isRelative(from) &amp;&amp; this.isAbsolute(path)) {
   return this.normalize(path);
 }

 // If the given path is relative, resolve it relative to the root of the
 // builder.
 if (this.isRelative(path) || this.isRootRelative(path)) {
   path = this.resolve(path);
 }

 // If the path is still relative and `from` is absolute, we're unable to
 // find a path from `from` to `path`.
 if (this.isRelative(path) &amp;&amp; this.isAbsolute(from)) {
   throw new ArgumentError('Unable to find a path to "$path" from "$from".');
 }

 var fromParsed = _parse(from)..normalize();
 var pathParsed = _parse(path)..normalize();

 if (fromParsed.parts.length &gt; 0 &amp;&amp; fromParsed.parts[0] == '.') {
   return pathParsed.toString();
 }

 // If the root prefixes don't match (for example, different drive letters
 // on Windows), then there is no relative path, so just return the absolute
 // one. In Windows, drive letters are case-insenstive and we allow
 // calculation of relative paths, even if a path has not been normalized.
 if (fromParsed.root != pathParsed.root &amp;&amp;
     ((fromParsed.root ==  null || pathParsed.root == null) ||
       fromParsed.root.toLowerCase().replaceAll('/', '\\') !=
       pathParsed.root.toLowerCase().replaceAll('/', '\\'))) {
   return pathParsed.toString();
 }

 // Strip off their common prefix.
 while (fromParsed.parts.length &gt; 0 &amp;&amp; pathParsed.parts.length &gt; 0 &amp;&amp;
        fromParsed.parts[0] == pathParsed.parts[0]) {
   fromParsed.parts.removeAt(0);
   fromParsed.separators.removeAt(1);
   pathParsed.parts.removeAt(0);
   pathParsed.separators.removeAt(1);
 }

 // If there are any directories left in the from path, we need to walk up
 // out of them. If a directory left in the from path is '..', it cannot
 // be cancelled by adding a '..'.
 if (fromParsed.parts.length &gt; 0 &amp;&amp; fromParsed.parts[0] == '..') {
   throw new ArgumentError('Unable to find a path to "$path" from "$from".');
 }
 _growListFront(pathParsed.parts, fromParsed.parts.length, '..');
 pathParsed.separators[0] = '';
 pathParsed.separators.insertAll(1,
     new List.filled(fromParsed.parts.length, style.separator));

 // Corner case: the paths completely collapsed.
 if (pathParsed.parts.length == 0) return '.';

 // Corner case: path was '.' and some '..' directories were added in front.
 // Don't add a final '/.' in that case.
 if (pathParsed.parts.length &gt; 1 &amp;&amp; pathParsed.parts.last == '.') {
   pathParsed.parts.removeLast();
   pathParsed.separators..removeLast()..removeLast()..add('');
 }

 // Make it relative.
 pathParsed.root = '';
 pathParsed.removeTrailingSeparators();

 return pathParsed.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="resolve">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>resolve</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part1, [<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part2, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part3, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part4, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part5, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part6, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part7]) <a class="anchor-link" href="#resolve"
              title="Permalink to Builder.resolve">#</a></h4>
<div class="doc">
<p>Creates a new path by appending the given path parts to the <a class="crossref" href="../path/Builder.html#root">root</a>.
Equivalent to <code>join()</code> with <a class="crossref" href="../path/Builder.html#root">root</a> as the first argument. Example:</p>
<pre><code>var builder = new Builder(root: 'root');
builder.resolve('path', 'to', 'foo'); // -&gt; 'root/path/to/foo'
</code></pre>
<pre class="source">
String resolve(String part1, [String part2, String part3, String part4,
           String part5, String part6, String part7]) {
 return join(root, part1, part2, part3, part4, part5, part6, part7);
}
</pre>
</div>
</div>
<div class="method"><h4 id="rootPrefix">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>rootPrefix</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#rootPrefix"
              title="Permalink to Builder.rootPrefix">#</a></h4>
<div class="doc">
<p>Returns the root of 
<span class="param">path</span>, if it's absolute, or an empty string if it's
relative.</p>
<pre><code>// Unix
builder.rootPrefix('path/to/foo'); // -&gt; ''
builder.rootPrefix('/path/to/foo'); // -&gt; '/'

// Windows
builder.rootPrefix(r'path\to\foo'); // -&gt; ''
builder.rootPrefix(r'C:\path\to\foo'); // -&gt; r'C:\'

// URL
builder.rootPrefix('path/to/foo'); // -&gt; ''
builder.rootPrefix('http://dartlang.org/path/to/foo');
  // -&gt; 'http://dartlang.org'
</code></pre>
<pre class="source">
String rootPrefix(String path) {
 var root = _parse(path).root;
 return root == null ? '' : root;
}
</pre>
</div>
</div>
<div class="method"><h4 id="split">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>&gt; <strong>split</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#split"
              title="Permalink to Builder.split">#</a></h4>
<div class="doc">
<p>Splits 
<span class="param">path</span> into its components using the current platform's
<a class="crossref" href="../path/Builder.html#separator">separator</a>. Example:</p>
<pre><code>builder.split('path/to/foo'); // -&gt; ['path', 'to', 'foo']
</code></pre>
<p>The path will <em>not</em> be normalized before splitting.</p>
<pre><code>builder.split('path/../foo'); // -&gt; ['path', '..', 'foo']
</code></pre>
<p>If 
<span class="param">path</span> is absolute, the root directory will be the first element in the
array. Example:</p>
<pre><code>// Unix
builder.split('/path/to/foo'); // -&gt; ['/', 'path', 'to', 'foo']

// Windows
builder.split(r'C:\path\to\foo'); // -&gt; [r'C:\', 'path', 'to', 'foo']
</code></pre>
<pre class="source">
List&lt;String&gt; split(String path) {
 var parsed = _parse(path);
 // Filter out empty parts that exist due to multiple separators in a row.
 parsed.parts = parsed.parts.where((part) =&gt; !part.isEmpty)
                            .toList();
 if (parsed.root != null) parsed.parts.insert(0, parsed.root);
 return parsed.parts;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toUri">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Uri.html" ref="external">Uri</a> <strong>toUri</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#toUri"
              title="Permalink to Builder.toUri">#</a></h4>
<div class="doc">
<p>Returns the URI that represents 
<span class="param">path</span>.</p>
<p>For POSIX and Windows styles, this will return a <code>file:</code> URI. For the URL
style, this will just convert 
<span class="param">path</span> to a <a class="crossref" href="http://api.dartlang.org/dart_core/Uri.html">Uri</a>.</p>
<pre><code>// POSIX
builder.toUri('/path/to/foo')
  // -&gt; Uri.parse('file:///path/to/foo')

// Windows
builder.toUri(r'C:\path\to\foo')
  // -&gt; Uri.parse('file:///C:/path/to/foo')

// URL
builder.toUri('http://dartlang.org/path/to/foo')
  // -&gt; Uri.parse('http://dartlang.org/path/to/foo')
</code></pre>
<pre class="source">
Uri toUri(String path) {
 if (isRelative(path)) {
   return style.relativePathToUri(path);
 } else {
   return style.absolutePathToUri(join(root, path));
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="withoutExtension">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>withoutExtension</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#withoutExtension"
              title="Permalink to Builder.withoutExtension">#</a></h4>
<div class="doc">
<p>Removes a trailing extension from the last part of 
<span class="param">path</span>.</p>
<pre><code>builder.withoutExtension('path/to/foo.dart'); // -&gt; 'path/to/foo'
</code></pre>
<pre class="source">
String withoutExtension(String path) {
 var parsed = _parse(path);

 for (var i = parsed.parts.length - 1; i &gt;= 0; i--) {
   if (!parsed.parts[i].isEmpty) {
     parsed.parts[i] = parsed.basenameWithoutExtension;
     break;
   }
 }

 return parsed.toString();
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
